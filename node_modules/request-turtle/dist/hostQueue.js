function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

const timer = require('./timer');
const config = require('./config');

const symbols = {
  requests: Symbol('requests'),
  dequeue: Symbol('dequeue'),
  draining: Symbol('draining'),
  tickFrequency: Symbol('tickFrequency'),
  warnUser: Symbol('warnUser'),
  drain: Symbol('drain')
};

class HostQueue {
  constructor(host, turtle) {
    this.host = host;
    this.frequency = 0;
    this.turtle = turtle;
    this[symbols.requests] = [];
    this[symbols.draining] = false;
  }

  get size() {
    return this[symbols.requests].length;
  }

  get isRateLimitExceeded() {
    return this.frequency > this.turtle.config.warningFrequency;
  }

  enqueue(req) {
    this[symbols.tickFrequency]();
    if (this.isRateLimitExceeded) {
      this[symbols.warnUser]();
    }
    this[symbols.requests].push(req);
    return this[symbols.drain]();
  }

  [symbols.tickFrequency]() {
    this.frequency++;
    setTimeout(() => this.frequency--, 1000);
  }

  [symbols.warnUser]() {
    console.warn('--YOU ARE MAKING TOO MANY REQUESTS TO', this.host, '--');
    console.warn('  Request frequency', this.frequency);
    console.warn('  we are rate limiting requests to', this.host);
    console.warn('  but if we weren\'t it would be bad.');
  }

  [symbols.drain]() {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (_this[symbols.draining]) {
        return;
      }
      _this[symbols.draining] = true;
      while (_this.size) {
        const req = _this[symbols.dequeue]();
        yield req.execute();
        yield timer(_this.turtle.config.waitingPeriod);
      }
      _this[symbols.draining] = false;
    })();
  }

  [symbols.dequeue]() {
    return this[symbols.requests].shift();
  }
}

module.exports = HostQueue;